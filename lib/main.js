// Generated by CoffeeScript 1.4.0
(function() {
  var Curve, Draw, Layer, Main,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Math.round = (function() {
    var oldRound;
    oldRound = Math.round;
    return function(number, precision) {
      var coefficient;
      precision = Math.abs(parseInt(precision)) || 0;
      coefficient = Math.pow(10, precision);
      return oldRound(number * coefficient) / coefficient;
    };
  })();

  $(function() {
    return new Main();
  });

  Main = (function() {

    function Main() {
      this.configure = __bind(this.configure, this);
      this.dataSeries = __bind(this.dataSeries, this);
      this.errorDiagram = __bind(this.errorDiagram, this);
      this.runAnimate = __bind(this.runAnimate, this);
      var _this = this;
      this.downReduceLimit = 3;
      $('#animate').bind('click', function() {
        return _this.runAnimate();
      });
      $('#example1').bind('click', function() {
        var c1, initialPoints;
        initialPoints = [[180, 319], [230, 40], [29, 266], [143, 449], [306, 33], [313, 155], [138, 18]];
        c1 = new Curve("c1", initialPoints);
        return _this.configure(c1);
      });
    }

    Main.prototype.runAnimate = function() {
      var frame, nre, step,
        _this = this;
      step = 0;
      frame = function() {
        if (step <= _this.downReduceLimit) {
          step++;
          return _this.draw.layer.drawAnimate(_this.draw.curveLayer.layer.getCanvas(), step, '#ff0000');
        } else {
          clearInterval(nre);
          return _this.errorDiagram();
        }
      };
      return nre = setInterval(frame, 1000);
    };

    Main.prototype.errorDiagram = function() {
      var chart;
      console.log(this.draw.layer.errorData(1));
      return chart = new Highcharts.Chart({
        chart: {
          renderTo: "error-diagram",
          type: "area"
        },
        title: {
          text: "Wykres błędu"
        },
        yAxis: {
          title: {
            text: "Wartość błędu"
          },
          labels: {
            formatter: function() {
              return this.value;
            }
          }
        },
        plotOptions: {
          area: {
            pointStart: 0.0,
            marker: {
              enabled: false,
              symbol: "circle",
              radius: 2,
              states: {
                hover: {
                  enabled: true
                }
              }
            }
          }
        },
        series: this.dataSeries()
      });
    };

    Main.prototype.dataSeries = function() {
      var i, series, _i, _ref;
      series = [];
      for (i = _i = 1, _ref = this.downReduceLimit; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        series.push({
          name: "Stopien o " + i + " niższy",
          data: this.draw.layer.errorData(i)
        });
      }
      return series;
    };

    Main.prototype.configure = function(c1) {
      var _this = this;
      $('#curves').children('.kineticjs-content').remove();
      this.draw = new Draw("curves");
      this.draw.layer.addCurve(c1);
      this.draw.layer.layer.beforeDraw(function() {
        _this.draw.layer.draw(_this.draw.curveLayer.layer.getCanvas());
        return _this.draw.layer.updateDottedLines();
      });
      this.draw.stage.on("mouseout", function() {
        return _this.draw.layer.layer.draw();
      });
      return this.draw.run();
    };

    return Main;

  })();

  Draw = (function() {

    function Draw(id, width, height) {
      if (width == null) {
        width = 800;
      }
      if (height == null) {
        height = 600;
      }
      this.run = __bind(this.run, this);
      this.clear = __bind(this.clear, this);
      this.stage = new Kinetic.Stage({
        container: id,
        width: width,
        height: height
      });
      this.layer = new Layer();
      this.curveLayer = new Layer();
    }

    Draw.prototype.clear = function() {
      this.curveLayer.layer.clear();
      return this.layer.layer.clear();
    };

    Draw.prototype.run = function() {
      this.stage.add(this.curveLayer.layer);
      return this.stage.add(this.layer.layer);
    };

    return Draw;

  })();

  Layer = (function() {

    function Layer() {
      this.reducedControlPoints = __bind(this.reducedControlPoints, this);
      this.reduceDegree = __bind(this.reduceDegree, this);
      this.reduce = __bind(this.reduce, this);
      this.errorData = __bind(this.errorData, this);
      this.testPoints = __bind(this.testPoints, this);
      this.error = __bind(this.error, this);
      this.P = __bind(this.P, this);
      this.B = __bind(this.B, this);
      this.fact = __bind(this.fact, this);
      this.drawAnimate = __bind(this.drawAnimate, this);
      this.draw = __bind(this.draw, this);
      this.parseToArray = __bind(this.parseToArray, this);
      this.parseToFlatten = __bind(this.parseToFlatten, this);
      this.clear = __bind(this.clear, this);
      this.updateDottedLines = __bind(this.updateDottedLines, this);
      this.curvePoints = __bind(this.curvePoints, this);
      this.addCurve = __bind(this.addCurve, this);      this.layer = new Kinetic.Layer();
      this.curves = [];
      this.colors = ['#24609d', '#ff0000'];
      this.N = 100;
      this.curvesControlPoints = [];
    }

    Layer.prototype.addCurve = function(curve) {
      this.curves.push(curve);
      this.layer.add(curve.line);
      return curve.buildAnchors(this.layer);
    };

    Layer.prototype.curvePoints = function(curve) {
      var _this = this;
      return _.flatten(_.map(curve.anchors, function(p) {
        return [p.attrs.x, p.attrs.y];
      }));
    };

    Layer.prototype.updateDottedLines = function() {
      var _this = this;
      return _.each(this.curves, function(c) {
        var cline, points;
        points = _this.curvePoints(c);
        cline = _this.layer.get("#" + c.id)[0];
        return cline.setPoints(points);
      });
    };

    Layer.prototype.clear = function() {
      return this.layer.removeChildren();
    };

    Layer.prototype.parseToFlatten = function(points) {
      var _this = this;
      return _.flatten(_.map(points, function(p) {
        return [p[0], p[1]];
      }));
    };

    Layer.prototype.parseToArray = function(points) {
      var i, outPoints;
      outPoints = [];
      i = 0;
      while (i < points.length) {
        outPoints.push([points[i], points[i + 1]]);
        i = i + 2;
      }
      return outPoints;
    };

    Layer.prototype.draw = function(canvas) {
      var context,
        _this = this;
      canvas.clear();
      context = canvas.getContext("2d");
      return _.each(this.curves, function(c, i) {
        var points;
        points = _this.curvePoints(c);
        return context.bezier(_this.N, points, _this.colors[i]);
      });
    };

    Layer.prototype.drawAnimate = function(canvas, reduce, color) {
      var context, drawedPoints, points;
      this.draw(canvas);
      context = canvas.getContext("2d");
      points = this.curvePoints(this.curves[0]);
      drawedPoints = this.parseToFlatten(this.reduce(this.parseToArray(points), reduce));
      this.curvesControlPoints.push(drawedPoints);
      return context.bezier(this.N, drawedPoints, color);
    };

    Layer.prototype.distance = function(a, b) {
      return Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));
    };

    Layer.prototype.fact = function(k) {
      if (k === 0 || k === 1) {
        return 1;
      } else {
        return k * this.fact(k - 1);
      }
    };

    Layer.prototype.B = function(i, n, t) {
      return this.fact(n) / (this.fact(i) * this.fact(n - i)) * Math.pow(t, i) * Math.pow(1 - t, n - i);
    };

    Layer.prototype.P = function(t, points) {
      var i, n, r;
      r = [0, 0];
      n = points.length - 1;
      i = 0;
      while (i <= n) {
        r[0] += points[i][0] * this.B(i, n, t);
        r[1] += points[i][1] * this.B(i, n, t);
        i++;
      }
      return r;
    };

    Layer.prototype.error = function(p1, p2, t) {
      return this.distance(this.P(t, p1), this.P(t, p2));
    };

    Layer.prototype.testPoints = function() {
      var DN, i, _i, _ref;
      DN = [];
      for (i = _i = 0, _ref = this.N; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        DN.push(i / this.N);
      }
      DN.push(1);
      return DN;
    };

    Layer.prototype.errorData = function(reduceDegree) {
      var errors, original, points,
        _this = this;
      errors = [];
      original = this.curvesControlPoints[0];
      points = this.curvesControlPoints[reduceDegree];
      _.each(this.testPoints(), function(t) {
        return errors.push(_this.error(_this.parseToArray(original), _this.parseToArray(points), t));
      });
      return errors;
    };

    Layer.prototype.reduce = function(initialPoints, reduce) {
      var points;
      points = initialPoints;
      while (reduce > 0) {
        points = this.reduceDegree(points);
        reduce--;
      }
      return points;
    };

    Layer.prototype.reduceDegree = function(initialPoints) {
      var P, degree, i, rXs, rYs, xs, ys, _i, _ref,
        _this = this;
      degree = initialPoints.length - 1;
      xs = initialPoints.map(function(p) {
        return p[0];
      });
      ys = initialPoints.map(function(p) {
        return p[1];
      });
      rXs = this.reducedControlPoints(xs);
      rYs = this.reducedControlPoints(ys);
      P = [];
      for (i = _i = 0, _ref = degree - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        P[i] = [];
        P[i][0] = rXs[i];
        P[i][1] = rYs[i];
      }
      return P;
    };

    Layer.prototype.reducedControlPoints = function(initialPoints) {
      var P, PL, PR, Q, i, p, r, _i, _j, _k, _ref, _ref1, _ref2, _ref3;
      Q = initialPoints;
      p = initialPoints.length - 1;
      r = (p - 1) / 2;
      if (!(p > 2)) {
        throw "To small curve degree";
        return 0;
      }
      P = [];
      for (i = _i = 0; 0 <= p ? _i <= p : _i >= p; i = 0 <= p ? ++_i : --_i) {
        P[i] = 0;
      }
      P[0] = Q[0];
      P[p - 1] = Q[p];
      for (i = _j = 1, _ref = p - 2; 1 <= _ref ? _j <= _ref : _j >= _ref; i = 1 <= _ref ? ++_j : --_j) {
        P[i] = (p * Q[i] - i * P[i - 1]) / (p - i);
      }
      for (i = _k = _ref1 = p - 2, _ref2 = r + 1; _ref1 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = _ref1 <= _ref2 ? ++_k : --_k) {
        P[i] = (p * Q[i + 1] - (p - i - 1.0) * P[i + 1]) / (i + 1.0);
      }
      if (p % 2 !== 0) {
        _ref3 = [0, 0], PL = _ref3[0], PR = _ref3[1];
        PL = (p * Q[r] - r * P[r - 1]) / (p - r);
        PR = (p * Q[r + 1] - (p - r - 1.0) * P[r + 1]) / (r + 1.0);
        P[r] = 0.5 * (PL + PR);
      }
      return P;
    };

    return Layer;

  })();

  Curve = (function() {

    function Curve(id, points) {
      this.id = id;
      this.points = points;
      this.anchor = __bind(this.anchor, this);
      this.buildAnchors = __bind(this.buildAnchors, this);
      this.line = new Kinetic.Line({
        dashArray: [10, 10, 0, 10],
        strokeWidth: 1,
        stroke: "grey",
        lineCap: "round",
        id: this.id,
        opacity: 0.1
      });
      this.anchors = [];
    }

    Curve.prototype.buildAnchors = function(layer) {
      var _this = this;
      return _.each(this.points, function(p, i) {
        return _this.anchors.push(_this.anchor(layer, p[0], p[1]));
      });
    };

    Curve.prototype.anchor = function(layer, x, y) {
      var anchor,
        _this = this;
      anchor = new Kinetic.Circle({
        x: x,
        y: y,
        radius: 3,
        stroke: "#666",
        fill: "#ddd",
        strokeWidth: 4,
        draggable: true
      });
      anchor.on("mouseover", function() {
        document.body.style.cursor = "pointer";
        return layer.draw();
      });
      anchor.on("mouseout", function() {
        document.body.style.cursor = "default";
        return layer.draw();
      });
      layer.add(anchor);
      return anchor;
    };

    return Curve;

  })();

}).call(this);
